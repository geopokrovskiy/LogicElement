package com.geopokrovskiy.model;

import java.lang.reflect.InvocationTargetException;
import java.util.Arrays;

public abstract class LogicElement {
    private boolean[] entries;

    /**
     * default constructor
     */
    public LogicElement() {
    }

    /**
     * parameter constructor
     *
     * @param n
     */
    public LogicElement(int n) {
        this.entries = new boolean[n];
    }

    /**
     * fill
     * method with a variable number of arguments like boolean,
     * Copping these arguments in the massive field,
     * Using the System.arrayCopy method. If the number of arguments is less
     * The length of the initial array must be generated by the exclusion of IllegalArgumentException with a message.
     */
    public void fill(boolean... args) throws IllegalArgumentException, NullPointerException {
        if (args.length < entries.length) {
            throw new IllegalArgumentException("Insufficient size!");
        }
        System.arraycopy(args, 0, this.entries, 0, this.entries.length);
    }

    /**
     * getLength
     * returns the number of entries in logic element
     *
     * @return
     */
    public int getLength() {
        return this.entries.length;
    }

    /**
     * Declare the abstract Protected Operation method, which takes two arguments like Boolean to the input,
     * which will return the result of a logical operation determined in the classroom for LogicElement
     */
    protected abstract boolean operation(boolean a, boolean b);


    /**
     * Implement the Result method that calculates the value at the output of the logical element,
     * using n its inputs and the Operation method
     * @return
     */
    public boolean result() {
        boolean res = this.entries[0];
        for (int i = 1; i < this.entries.length; i++) {
            res = operation(res, this.entries[i]);
        }
        return res;
    }


    /**
     * Implement the union method, accepting the second logical element to the input and
     * Providing the association of two logical elements, returning the new one.
     * In case of mismatch of the type of initial logical element with the type of conveyed argument, generate the exclusion of ClassCastException.
     * To create an object, dynamically determining its type, use the methods of reflection.
     * @param
     * @return
     */
    public LogicElement union(LogicElement other) {
        if (other.getClass() != this.getClass()) {
            throw new ClassCastException("Argument incompatible with the current object.");
        }
        try {
            LogicElement result = this.getClass().getConstructor(int.class)
                    .newInstance(other.getLength() + this.getLength());
            System.arraycopy(this.entries, 0, result.entries, 0, this.getLength());
            System.arraycopy(other.entries, 0, result.entries, this.getLength(), other.getLength());
            return result;
        } catch (Exception ignored) {
        }
        return null;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        LogicElement that = (LogicElement) o;
        return Arrays.equals(entries, that.entries);
    }

    @Override
    public int hashCode() {
        return Arrays.hashCode(entries);
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName() + "{" +
                "entries=" + Arrays.toString(entries) +
                '}';
    }
}
